# WORK: Define EPIC-TIDE Vocabulary (v4 AI-Native)
# Self-contained vocabulary specification with semantic validation

WORK:
  id: define-vocabulary
  what: "Create comprehensive vocabulary specification for EPIC-TIDE system semantic consistency"
  
  # CONTEXT - Task environment
  context:
    location: System architecture and data modeling phase
    prerequisites:
      - "Understanding of EPIC-TIDE core concepts (WORK, PATH, TIDE, PATTERN)"
      - "Database schema requirements known"
      - "API contract needs identified"
    outputs:
      - "Complete vocabulary specification document"
      - "Validation schemas for each controlled field"
      - "Semantic field separation guidelines"
      - "API integration constants"
    dependencies: []
    
  # KNOWLEDGE - Critical vocabulary design information
  knowledge:
    - "Controlled vocabulary prevents data inconsistency and enables reliable queries"
    - "Semantic fields (user-meaningful) must be separated from system fields (IDs, timestamps)"
    - "Status transitions have logical constraints (pending→in_progress→completed/failed)"
    - "Adaptation types categorize how execution differs from original plan"
    - "Outcome values reflect TIDE success level for pattern extraction"
    - "Field separation enables AI agents to focus on semantics while system handles technical aspects"
    - "Aliases provide flexibility while maintaining core vocabulary integrity"
  
  # EXECUTION
  how:
    - "Define all controlled vocabulary values with descriptions"
    - "Separate semantic fields from system fields clearly"
    - "Create validation rules and constraints"
    - "Define semantic aliases for user flexibility"
    - "Specify field usage contexts and examples"
    - "Create integration constants for API usage"
  
  metrics:
    - "All controlled values defined with descriptions"
    - "Field separation documented with examples"
    - "Validation rules specified for each field type"
    - "Semantic aliases mapped to core vocabulary"
  
  # LEARNINGS - From vocabulary design experience
  learnings:
    - source: "Initial system design"
      learning: "Controlled vocabulary must be established before any data creation"
    - source: "API integration testing"
      learning: "Aliases reduce user friction while maintaining data consistency"
    - source: "AI agent usage"
      learning: "Clear semantic vs system field separation helps AI focus on meaningful content"
    - source: "Pattern extraction"
      learning: "Consistent adaptation types enable automatic pattern recognition"
  
  # TROUBLESHOOTING - Common vocabulary issues
  troubleshooting:
    - issue: "Invalid vocabulary values in database"
      symptoms: "API returns 400 errors, data queries return unexpected results"
      solution: "Add CHECK constraints at database level, validate at API level"
      prevention: "Define vocabulary before any data insertion, use constants in code"
    
    - issue: "AI agents invent new status values"
      symptoms: "Status values like 'working', 'done', 'error' appear in requests"
      solution: "Provide explicit vocabulary lists in AI instructions"
      prevention: "Include vocabulary constants in all AI agent documentation"
    
    - issue: "Inconsistent adaptation categorization"
      symptoms: "Similar adaptations get different types, pattern extraction fails"
      solution: "Provide clear examples for each adaptation type"
      prevention: "Include decision tree for adaptation type selection"
    
    - issue: "Semantic vs system field confusion"
      symptoms: "APIs mix user content with system metadata"
      solution: "Use clear naming conventions (semantic vs technical fields)"
      prevention: "Document field purposes explicitly in API contracts"
  
  # COMPLETE IMPLEMENTATION
  artifacts:
    vocabulary_specification: |
      # EPIC-TIDE Vocabulary Specification v1.0
      
      ## Controlled Vocabulary
      
      ### STATUS (WORK/TIDE execution state)
      - **pending**: Ready to execute, not yet started
      - **in_progress**: Currently being executed
      - **completed**: Execution finished successfully
      - **failed**: Execution failed and cannot continue
      
      #### Status Transitions
      ```
      pending → in_progress → completed
                             → failed
      ```
      
      ### OUTCOME (TIDE result classification)
      - **success**: All planned WORKs completed as intended
      - **partial**: Some WORKs completed, others failed or skipped
      - **failed**: TIDE could not accomplish its goals
      
      ### ADAPTATION_TYPE (How execution differed from plan)
      - **sequence_change**: Modified order of WORK execution
      - **parameter_adjustment**: Changed configuration values or settings
      - **tool_substitution**: Used different tools than originally specified
      - **requirement_relaxation**: Accepted partial completion of requirements
      - **scope_expansion**: Added steps not in original plan
      - **dependency_resolution**: Modified dependencies or prerequisites
      
      ### PATTERN_CONFIDENCE (Pattern extraction reliability)
      - **high**: Pattern appears in 80%+ of similar TIDEs
      - **medium**: Pattern appears in 50-79% of similar TIDEs  
      - **low**: Pattern appears in 20-49% of similar TIDEs
      - **experimental**: Pattern identified but needs validation
      
      ## Field Classification
      
      ### Semantic Fields (User-meaningful content)
      - **what**: Human-readable description of purpose
      - **how**: Steps or methods for execution
      - **metrics**: Success criteria in user terms
      - **learnings**: Insights gained from execution
      - **adaptations**: Changes made during execution
      - **why**: Reasoning or justification
      
      ### System Fields (Technical metadata)
      - **[entity]_id**: Unique identifiers (work_id, path_id, tide_id)
      - **created_at/updated_at**: Timestamps
      - **version**: System version numbers
      - **[field]_vector**: Embedding vectors for search
      - **attempt**: Sequence numbers
      - **status**: Controlled state values
      
      ## Semantic Aliases
      
      Allow flexibility while mapping to core vocabulary:
      
      ### Status Aliases
      ```yaml
      Core: pending
      Aliases: [waiting, ready, queued, todo]
      
      Core: in_progress  
      Aliases: [running, executing, working, active]
      
      Core: completed
      Aliases: [done, finished, successful, complete]
      
      Core: failed
      Aliases: [error, broken, unsuccessful, aborted]
      ```
      
      ### Outcome Aliases
      ```yaml
      Core: success
      Aliases: [complete, successful, achieved]
      
      Core: partial
      Aliases: [incomplete, mixed, some_success]
      
      Core: failed
      Aliases: [unsuccessful, broken, aborted]
      ```
      
      ## Validation Rules
      
      ### Status Validation
      - Must be one of: [pending, in_progress, completed, failed]
      - Transitions must follow logical flow
      - Only one TIDE per PATH can be in_progress
      
      ### Adaptation Validation
      - Type must be from controlled vocabulary
      - Reason must be non-empty string
      - Change description must specify what was modified
      
      ### Vector Validation
      - All vectors must be 1024 dimensions (E5-large-v2)
      - Null vectors allowed if embedding generation fails
      - Vector values must be finite numbers
      
      ## Integration Constants
      
      For use in API implementations and AI agents:
      
      ```javascript
      const VOCABULARY = {
        STATUS: {
          PENDING: 'pending',
          IN_PROGRESS: 'in_progress', 
          COMPLETED: 'completed',
          FAILED: 'failed'
        },
        
        OUTCOME: {
          SUCCESS: 'success',
          PARTIAL: 'partial',
          FAILED: 'failed'
        },
        
        ADAPTATION_TYPE: {
          SEQUENCE_CHANGE: 'sequence_change',
          PARAMETER_ADJUSTMENT: 'parameter_adjustment',
          TOOL_SUBSTITUTION: 'tool_substitution',
          REQUIREMENT_RELAXATION: 'requirement_relaxation',
          SCOPE_EXPANSION: 'scope_expansion',
          DEPENDENCY_RESOLUTION: 'dependency_resolution'
        },
        
        PATTERN_CONFIDENCE: {
          HIGH: 'high',
          MEDIUM: 'medium', 
          LOW: 'low',
          EXPERIMENTAL: 'experimental'
        }
      };
      ```
    
    validation_schemas: |
      # JSON Schema Validation
      
      ## Status Schema
      ```json
      {
        "type": "string",
        "enum": ["pending", "in_progress", "completed", "failed"],
        "description": "Current execution state"
      }
      ```
      
      ## Adaptation Schema
      ```json
      {
        "type": "object",
        "required": ["type", "reason", "change"],
        "properties": {
          "type": {
            "type": "string",
            "enum": ["sequence_change", "parameter_adjustment", "tool_substitution", 
                     "requirement_relaxation", "scope_expansion", "dependency_resolution"]
          },
          "reason": {
            "type": "string",
            "minLength": 10,
            "description": "Why this adaptation was needed"
          },
          "change": {
            "type": "string", 
            "minLength": 10,
            "description": "What specifically was changed"
          },
          "impact": {
            "type": "string",
            "enum": ["minor", "moderate", "major"],
            "description": "Severity of deviation from original plan"
          }
        }
      }
      ```
      
      ## Vector Schema
      ```json
      {
        "type": ["array", "null"],
        "items": {
          "type": "number",
          "minimum": -1,
          "maximum": 1
        },
        "minItems": 1024,
        "maxItems": 1024,
        "description": "1024-dimensional embedding vector or null"
      }
      ```
    
    field_separation_guide: |
      # Field Separation Guidelines
      
      ## Semantic vs System Field Decision Tree
      
      ### Ask: "Does a human care about this value for understanding the work?"
      - **YES** → Semantic field
      - **NO** → System field
      
      ### Examples:
      
      **Semantic Fields (human-meaningful):**
      - what: "Setup Node.js project" ✓
      - how: ["Create package.json", "Install deps"] ✓
      - learnings: "Timeout was too short" ✓
      - adaptations: [{type: "parameter_adjustment", reason: "..."}] ✓
      
      **System Fields (technical metadata):**
      - work_id: "work_1735123456_a1b2" ✓
      - created_at: "2025-01-27T10:30:00Z" ✓
      - what_vector: [0.1, -0.2, 0.3, ...] ✓
      - attempt: 2 ✓
      
      ## API Design Implications
      
      ### Semantic Fields:
      - Include in search results
      - Allow user modification
      - Use for similarity matching
      - Include in pattern extraction
      
      ### System Fields:  
      - Generated by server
      - Immutable after creation
      - Used for internal operations
      - Hidden from casual users
      
      ## AI Agent Guidelines
      
      ### Claude Code Should:
      - Focus on semantic fields for decision-making
      - Never generate system field values
      - Validate semantic fields against vocabulary
      - Use semantic fields for learning capture
      
      ### Claude Code Should NOT:
      - Create work_id, path_id, tide_id values
      - Modify timestamps directly
      - Generate embedding vectors
      - Change system version numbers
    
    usage_examples: |
      # Vocabulary Usage Examples
      
      ## Valid WORK Creation
      ```json
      {
        "what": "Implement user authentication",
        "how": [
          "Create user model with bcrypt password hashing",
          "Implement JWT token generation", 
          "Add login/logout endpoints",
          "Create middleware for protected routes"
        ],
        "metrics": [
          "Users can register and login",
          "Passwords are securely hashed", 
          "JWT tokens expire appropriately",
          "Protected routes require authentication"
        ]
      }
      ```
      
      ## Valid TIDE Update with Adaptations
      ```json
      {
        "status": "completed",
        "execution": {
          "implement-user-auth": "completed"
        },
        "outcome": "success", 
        "adaptations": [
          {
            "type": "tool_substitution",
            "reason": "bcrypt not available in environment",
            "change": "Used built-in crypto module for password hashing",
            "impact": "minor"
          }
        ],
        "learnings": "Environment compatibility should be checked before starting implementation",
        "metrics_achieved": {
          "Users can register and login": true,
          "Passwords are securely hashed": true,
          "JWT tokens expire appropriately": true, 
          "Protected routes require authentication": true
        }
      }
      ```
      
      ## Invalid Examples (What NOT to do)
      ```json
      // ❌ Invalid status value
      {
        "status": "working" // Should be "in_progress"
      }
      
      // ❌ Trying to set system fields
      {
        "work_id": "my-custom-id", // Server generates IDs
        "created_at": "2025-01-27T10:30:00Z" // Server sets timestamps
      }
      
      // ❌ Missing required adaptation fields
      {
        "adaptations": [
          {
            "type": "parameter_adjustment"
            // Missing required 'reason' and 'change' fields
          }
        ]
      }
      ```