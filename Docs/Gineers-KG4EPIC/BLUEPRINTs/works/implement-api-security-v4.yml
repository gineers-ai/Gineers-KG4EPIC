# WORK: Implement API Security (v4 AI-Native)
# Self-contained execution unit with embedded context

WORK:
  id: implement-api-security
  what: "Implement comprehensive API security with POST-only pattern and authentication"
  
  # CONTEXT - Environment and dependencies
  context:
    location: /Users/inseokseo/Gineers-Projects/Gineers-KG4EPIC
    prerequisites: 
      - "Node.js project setup with Express framework"
      - "Basic API routes implemented (from implement-post-api)"
      - "Environment variables configured"
    outputs:
      - "API key authentication middleware active"
      - "Rate limiting configured (100 req/min per IP)"
      - "POST-only CORS policy enforced"
      - "Security headers applied"
      - "Input validation and sanitization active"
    dependencies: ["implement-post-api", "setup-nodejs-project"]
    
  # KNOWLEDGE - Critical information
  knowledge:
    - "POST-only API design prevents CSRF attacks and accidental data exposure"
    - "Rate limiting essential for preventing abuse of embedding generation"
    - "API keys should be cryptographically secure (min 32 chars)"
    - "Express helmet middleware provides security headers out-of-the-box"
    - "Request body size limits prevent DoS attacks on large documents"
    - "Input sanitization prevents injection attacks on text content"
    - "Audit logging required for security compliance"
  
  # EXECUTION
  how:
    - "Install security middleware packages (helmet, express-rate-limit, express-validator)"
    - "Implement API key authentication middleware"
    - "Configure rate limiting (100 requests per minute per IP)"
    - "Setup CORS to only allow POST methods"
    - "Add request body size limits (10MB for documents)"
    - "Implement input validation for all endpoints"
    - "Add comprehensive security headers"
    - "Setup access logging with security events"
    - "Create API key generation utility"
  
  metrics:
    - "All endpoints require valid API key"
    - "Only POST requests accepted (OPTIONS for CORS preflight)"
    - "Rate limiting returns 429 status when exceeded"
    - "Security headers present in all responses"
    - "Input validation rejects malformed requests"
    - "Access logs capture authentication attempts"
  
  # LEARNINGS - From development experience
  learnings:
    - source: "Security Research"
      learning: "POST-only APIs significantly reduce attack surface compared to full REST"
    - source: "Performance Testing"
      learning: "Rate limiting must account for embedding generation latency"
    - source: "Production Deployment"
      learning: "API key rotation strategy essential for long-term security"
  
  # TROUBLESHOOTING - Known issues and fixes
  troubleshooting:
    - issue: "CORS preflight requests failing"
      symptoms: "Browser shows CORS error on POST requests"
      solution: "Allow OPTIONS method for CORS preflight, but not other methods"
      prevention: "Test with browser-based clients during development"
    
    - issue: "Rate limiting triggering on legitimate usage"
      symptoms: "429 errors during normal operation"
      solution: "Adjust rate limit based on embedding generation time (~2-3 seconds)"
      prevention: "Monitor rate limit metrics and adjust based on usage patterns"
      
    - issue: "API key validation performance impact"
      symptoms: "Increased response times on all endpoints"
      solution: "Use constant-time string comparison, consider caching valid keys"
      prevention: "Benchmark authentication middleware performance"
    
    - issue: "Request body too large errors"
      symptoms: "413 Payload Too Large for legitimate WORK documents"
      solution: "Increase body limit to 10MB, implement streaming for large docs"
      prevention: "Test with real WORK documents to determine appropriate limits"
  
  # COMPLETE IMPLEMENTATION
  artifacts:
    security_middleware: |
      // src/middleware/security.js
      const rateLimit = require('express-rate-limit');
      const helmet = require('helmet');
      const { body, validationResult } = require('express-validator');
      const crypto = require('crypto');
      
      // API Key Authentication
      const authenticateApiKey = (req, res, next) => {
        const apiKey = req.headers['x-api-key'] || req.headers['authorization']?.replace('Bearer ', '');
        
        if (!apiKey) {
          return res.status(401).json({ 
            error: 'API key required',
            code: 'MISSING_API_KEY'
          });
        }
        
        const expectedKey = process.env.API_KEY;
        if (!expectedKey) {
          console.error('API_KEY not configured in environment');
          return res.status(500).json({ error: 'Server configuration error' });
        }
        
        // Constant-time comparison to prevent timing attacks
        const keyBuffer = Buffer.from(apiKey, 'utf8');
        const expectedBuffer = Buffer.from(expectedKey, 'utf8');
        
        if (keyBuffer.length !== expectedBuffer.length) {
          return res.status(401).json({ 
            error: 'Invalid API key',
            code: 'INVALID_API_KEY'
          });
        }
        
        const isValid = crypto.timingSafeEqual(keyBuffer, expectedBuffer);
        
        if (!isValid) {
          console.warn('Invalid API key attempt:', {
            ip: req.ip,
            userAgent: req.get('User-Agent'),
            timestamp: new Date().toISOString()
          });
          return res.status(401).json({ 
            error: 'Invalid API key',
            code: 'INVALID_API_KEY'
          });
        }
        
        next();
      };
      
      // Rate Limiting
      const createRateLimit = rateLimit({
        windowMs: 60 * 1000, // 1 minute
        max: 100, // 100 requests per minute
        message: {
          error: 'Too many requests, please try again later',
          code: 'RATE_LIMIT_EXCEEDED',
          retryAfter: '60 seconds'
        },
        standardHeaders: true,
        legacyHeaders: false,
        handler: (req, res) => {
          console.warn('Rate limit exceeded:', {
            ip: req.ip,
            userAgent: req.get('User-Agent'),
            timestamp: new Date().toISOString()
          });
          res.status(429).json({
            error: 'Too many requests, please try again later',
            code: 'RATE_LIMIT_EXCEEDED',
            retryAfter: 60
          });
        }
      });
      
      // CORS Configuration (POST-only)
      const corsOptions = {
        origin: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],
        methods: ['POST', 'OPTIONS'], // Only POST and OPTIONS for preflight
        allowedHeaders: ['Content-Type', 'Authorization', 'X-API-Key'],
        credentials: true,
        optionsSuccessStatus: 200
      };
      
      // Input Validation Helpers
      const validateWorkDocument = [
        body('work_id').isString().trim().isLength({ min: 1, max: 100 }),
        body('content').isObject(),
        body('content.id').isString().trim(),
        body('content.what').isString().trim().isLength({ min: 1, max: 500 }),
        (req, res, next) => {
          const errors = validationResult(req);
          if (!errors.isEmpty()) {
            return res.status(400).json({
              error: 'Validation failed',
              code: 'VALIDATION_ERROR',
              details: errors.array()
            });
          }
          next();
        }
      ];
      
      const validateQuery = [
        body('query').isString().trim().isLength({ min: 1, max: 1000 }),
        body('limit').optional().isInt({ min: 1, max: 100 }),
        body('filters').optional().isObject(),
        (req, res, next) => {
          const errors = validationResult(req);
          if (!errors.isEmpty()) {
            return res.status(400).json({
              error: 'Validation failed',
              code: 'VALIDATION_ERROR',
              details: errors.array()
            });
          }
          next();
        }
      ];
      
      module.exports = {
        authenticateApiKey,
        createRateLimit,
        corsOptions,
        validateWorkDocument,
        validateQuery
      };
    
    app_security: |
      // src/app.js - Security configuration
      const express = require('express');
      const helmet = require('helmet');
      const cors = require('cors');
      const { 
        authenticateApiKey, 
        createRateLimit, 
        corsOptions 
      } = require('./middleware/security');
      
      const app = express();
      
      // Security Headers
      app.use(helmet({
        contentSecurityPolicy: {
          directives: {
            defaultSrc: ["'self'"],
            scriptSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'"],
            imgSrc: ["'self'", "data:", "https:"],
          },
        },
        crossOriginEmbedderPolicy: false // Allow embedding generation
      }));
      
      // CORS (POST-only)
      app.use(cors(corsOptions));
      
      // Body parsing with size limits
      app.use(express.json({ 
        limit: '10mb',
        verify: (req, res, buf) => {
          // Additional body validation can go here
          if (buf.length > 10 * 1024 * 1024) {
            throw new Error('Request body too large');
          }
        }
      }));
      
      app.use(express.urlencoded({ 
        extended: true, 
        limit: '10mb' 
      }));
      
      // Rate Limiting
      app.use(createRateLimit);
      
      // API Key Authentication (applied to all routes except health)
      app.get('/health', (req, res) => {
        res.json({ status: 'healthy', timestamp: new Date().toISOString() });
      });
      
      app.use('/api', authenticateApiKey);
      
      // Reject all non-POST requests (except OPTIONS for CORS)
      app.use((req, res, next) => {
        if (req.method === 'GET' && req.path === '/health') {
          return next();
        }
        
        if (req.method !== 'POST' && req.method !== 'OPTIONS') {
          return res.status(405).json({
            error: 'Method not allowed. Only POST requests accepted.',
            code: 'METHOD_NOT_ALLOWED',
            allowedMethods: ['POST']
          });
        }
        
        next();
      });
      
      // Security logging middleware
      app.use((req, res, next) => {
        const startTime = Date.now();
        
        res.on('finish', () => {
          const duration = Date.now() - startTime;
          const logEntry = {
            timestamp: new Date().toISOString(),
            method: req.method,
            path: req.path,
            ip: req.ip,
            userAgent: req.get('User-Agent'),
            statusCode: res.statusCode,
            duration,
            hasApiKey: !!req.headers['x-api-key'] || !!req.headers['authorization']
          };
          
          // Log security events
          if (res.statusCode === 401 || res.statusCode === 403) {
            console.warn('Security event:', logEntry);
          } else {
            console.log('API access:', logEntry);
          }
        });
        
        next();
      });
      
      module.exports = app;
    
    api_key_generator: |
      // scripts/generate-api-key.js
      const crypto = require('crypto');
      
      function generateApiKey(length = 32) {
        return crypto.randomBytes(length).toString('hex');
      }
      
      function generateSecureApiKey() {
        // Generate a 256-bit (32 byte) random key
        const randomBytes = crypto.randomBytes(32);
        
        // Convert to base64url for easier handling
        const key = randomBytes
          .toString('base64')
          .replace(/\+/g, '-')
          .replace(/\//g, '_')
          .replace(/=/g, '');
          
        return key;
      }
      
      if (require.main === module) {
        console.log('Generated API Key:');
        console.log(generateSecureApiKey());
        console.log('');
        console.log('Add to .env file:');
        console.log(`API_KEY=${generateSecureApiKey()}`);
      }
      
      module.exports = { generateApiKey, generateSecureApiKey };
    
    security_tests: |
      // tests/security.test.js
      const request = require('supertest');
      const app = require('../src/app');
      
      describe('API Security', () => {
        const validApiKey = process.env.API_KEY || 'test-key';
        
        describe('Authentication', () => {
          test('should reject requests without API key', async () => {
            const response = await request(app)
              .post('/api/works')
              .send({ test: 'data' });
              
            expect(response.status).toBe(401);
            expect(response.body.code).toBe('MISSING_API_KEY');
          });
          
          test('should reject requests with invalid API key', async () => {
            const response = await request(app)
              .post('/api/works')
              .set('X-API-Key', 'invalid-key')
              .send({ test: 'data' });
              
            expect(response.status).toBe(401);
            expect(response.body.code).toBe('INVALID_API_KEY');
          });
          
          test('should accept requests with valid API key', async () => {
            const response = await request(app)
              .post('/api/works')
              .set('X-API-Key', validApiKey)
              .send({ work_id: 'test', content: { id: 'test', what: 'test work' } });
              
            expect(response.status).not.toBe(401);
          });
        });
        
        describe('HTTP Methods', () => {
          test('should reject GET requests', async () => {
            const response = await request(app)
              .get('/api/works')
              .set('X-API-Key', validApiKey);
              
            expect(response.status).toBe(405);
            expect(response.body.code).toBe('METHOD_NOT_ALLOWED');
          });
          
          test('should reject PUT requests', async () => {
            const response = await request(app)
              .put('/api/works')
              .set('X-API-Key', validApiKey)
              .send({ test: 'data' });
              
            expect(response.status).toBe(405);
          });
          
          test('should allow POST requests', async () => {
            const response = await request(app)
              .post('/api/works')
              .set('X-API-Key', validApiKey)
              .send({ work_id: 'test', content: { id: 'test', what: 'test work' } });
              
            expect(response.status).not.toBe(405);
          });
        });
        
        describe('Rate Limiting', () => {
          test('should enforce rate limits', async () => {
            // This test would need to be run carefully to avoid affecting other tests
            // Consider using a separate rate limiter for testing
          });
        });
        
        describe('Input Validation', () => {
          test('should validate required fields', async () => {
            const response = await request(app)
              .post('/api/works')
              .set('X-API-Key', validApiKey)
              .send({}); // Missing required fields
              
            expect(response.status).toBe(400);
            expect(response.body.code).toBe('VALIDATION_ERROR');
          });
        });
      });
    
    security_config: |
      # Security Configuration Checklist
      
      ## Environment Variables
      ```env
      # Generate with: node scripts/generate-api-key.js
      API_KEY=your_secure_api_key_here_minimum_32_chars
      
      # CORS origins (comma-separated)
      ALLOWED_ORIGINS=http://localhost:3000,https://yourdomain.com
      
      # Rate limiting
      RATE_LIMIT_WINDOW_MS=60000
      RATE_LIMIT_MAX_REQUESTS=100
      
      # Body size limits
      MAX_BODY_SIZE=10mb
      ```
      
      ## Security Headers Verification
      ```bash
      # Test security headers
      curl -I -X POST http://localhost:3000/api/works \
        -H "X-API-Key: your-key" \
        -H "Content-Type: application/json"
      
      # Should include:
      # X-Content-Type-Options: nosniff
      # X-Frame-Options: DENY
      # X-XSS-Protection: 0
      # Strict-Transport-Security: max-age=15552000; includeSubDomains
      ```
      
      ## Rate Limit Testing
      ```bash
      # Test rate limiting
      for i in {1..105}; do
        curl -s -o /dev/null -w "%{http_code}\n" \
          -X POST http://localhost:3000/api/works \
          -H "X-API-Key: your-key" \
          -H "Content-Type: application/json" \
          -d '{"work_id":"test","content":{"id":"test","what":"test"}}'
      done
      # Should see 429 responses after 100 requests
      ```
    
    commands: |
      # Install security dependencies
      npm install helmet express-rate-limit express-validator cors
      npm install --save-dev supertest
      
      # Generate API key
      node scripts/generate-api-key.js
      
      # Run security tests
      npm test -- security.test.js
      
      # Test API endpoints with security
      curl -X POST http://localhost:3000/api/works \
        -H "X-API-Key: $API_KEY" \
        -H "Content-Type: application/json" \
        -d '{"work_id":"test","content":{"id":"test","what":"test work"}}'
      
      # Test rate limiting
      ab -n 110 -c 10 -H "X-API-Key: $API_KEY" \
        -T "application/json" \
        -p test-payload.json \
        http://localhost:3000/api/works
      
      # Verify security headers
      curl -I -X POST http://localhost:3000/api/works \
        -H "X-API-Key: $API_KEY" \
        -H "Content-Type: application/json"