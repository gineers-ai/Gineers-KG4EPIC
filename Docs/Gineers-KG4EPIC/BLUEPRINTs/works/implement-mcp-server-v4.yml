# WORK: Implement MCP Server (v4 AI-Native)
# Self-contained execution unit with embedded context

WORK:
  id: implement-mcp-server
  what: "Build MCP server with EPIC-TIDE tools for Claude integration"
  
  # CONTEXT - Environment and dependencies
  context:
    location: /Users/inseokseo/Gineers-Projects/Gineers-KG4EPIC
    prerequisites: 
      - "MCP tool specifications designed (from design-mcp-tools)"
      - "PostgreSQL+pgvector database running"
      - "API endpoints implemented"
      - "TypeScript development environment"
    outputs:
      - "MCP server running with 7 EPIC-TIDE tools"
      - "Tool validation using JSON schemas"
      - "Database integration for state management"
      - "Error handling and logging"
      - "Claude-compatible MCP implementation"
    dependencies: ["design-mcp-tools", "implement-storage-layer", "setup-postgres-pgvector"]
    
  # KNOWLEDGE - Critical information
  knowledge:
    - "MCP (Model Context Protocol) enables Claude to use custom tools"
    - "MCP server must implement JSON-RPC 2.0 protocol"
    - "Tools must be discoverable through list_tools method"
    - "MCP server runs as separate process, communicates via stdio"
    - "Tool execution must be atomic and return structured results"
    - "Server must handle concurrent tool calls gracefully"
    - "State management through database, not server memory"
  
  # EXECUTION
  how:
    - "Setup TypeScript MCP project with @modelcontextprotocol/sdk"
    - "Implement server initialization and tool registration"
    - "Create tool handlers for all 7 EPIC-TIDE tools"
    - "Add JSON schema validation for tool inputs"
    - "Integrate with PostgreSQL storage layer"
    - "Implement comprehensive error handling"
    - "Add structured logging and debugging"
    - "Create server configuration and startup script"
    - "Add health checks and monitoring"
  
  metrics:
    - "MCP server starts without errors"
    - "All 7 tools listed and callable"
    - "Input validation rejects malformed requests"
    - "Database operations complete successfully"
    - "Error responses follow MCP specification"
    - "Claude can discover and use tools"
  
  # LEARNINGS - From development experience
  learnings:
    - source: "MCP Documentation"
      learning: "MCP server must handle stdio communication properly for Claude integration"
    - source: "Tool Development"
      learning: "Tool state must be fully contained in parameters and database"
    - source: "Error Handling"
      learning: "MCP error codes must follow JSON-RPC 2.0 specification"
  
  # TROUBLESHOOTING - Known issues and fixes
  troubleshooting:
    - issue: "MCP server not discovered by Claude"
      symptoms: "Tools not appearing in Claude interface"
      solution: "Check server stdio communication and tool listing implementation"
      prevention: "Test MCP server with official MCP client tools"
    
    - issue: "Tool validation fails on complex objects"
      symptoms: "Valid tool calls rejected with schema errors"
      solution: "Use additionalProperties: true for flexible YAML content"
      prevention: "Test schemas with real WORK documents"
      
    - issue: "Database connection timeout in tools"
      symptoms: "Tools fail with connection errors"
      solution: "Implement connection pooling and retry logic"
      prevention: "Use database health checks before tool execution"
    
    - issue: "Concurrent tool calls interfere"
      symptoms: "Tool executions affect each other's state"
      solution: "Ensure tool atomicity with database transactions"
      prevention: "Design tools to be stateless and idempotent"
  
  # COMPLETE IMPLEMENTATION
  artifacts:
    package_json: |
      {
        "name": "epic-tide-mcp-server",
        "version": "1.0.0",
        "description": "MCP server for EPIC-TIDE methodology tools",
        "main": "dist/server.js",
        "scripts": {
          "build": "tsc",
          "start": "node dist/server.js",
          "dev": "tsx src/server.ts",
          "test": "jest",
          "lint": "eslint src --ext .ts",
          "type-check": "tsc --noEmit"
        },
        "dependencies": {
          "@modelcontextprotocol/sdk": "^0.4.0",
          "pg": "^8.11.3",
          "ajv": "^8.12.0",
          "winston": "^3.11.0",
          "dotenv": "^16.3.1",
          "uuid": "^9.0.1"
        },
        "devDependencies": {
          "@types/node": "^20.0.0",
          "@types/pg": "^8.10.7",
          "@types/uuid": "^9.0.6",
          "typescript": "^5.2.0",
          "tsx": "^4.0.0",
          "jest": "^29.7.0",
          "@types/jest": "^29.5.6",
          "eslint": "^8.52.0",
          "@typescript-eslint/eslint-plugin": "^6.9.0",
          "@typescript-eslint/parser": "^6.9.0"
        },
        "keywords": ["mcp", "epic-tide", "claude", "ai-tools"],
        "license": "MIT"
      }
    
    server_implementation: |
      // src/server.ts
      import { Server } from '@modelcontextprotocol/sdk/server/index.js';
      import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
      import {
        CallToolRequestSchema,
        ListToolsRequestSchema,
        Tool,
      } from '@modelcontextprotocol/sdk/types.js';
      import { z } from 'zod';
      import { DatabaseService } from './services/database.js';
      import { ToolRegistry } from './tools/registry.js';
      import { Logger } from './utils/logger.js';
      import { ConfigService } from './services/config.js';
      
      const logger = Logger.getInstance();
      
      class EpicTideMCPServer {
        private server: Server;
        private database: DatabaseService;
        private toolRegistry: ToolRegistry;
        private config: ConfigService;
        
        constructor() {
          this.config = new ConfigService();
          this.database = new DatabaseService(this.config);
          this.toolRegistry = new ToolRegistry(this.database);
          this.server = new Server(
            {
              name: 'epic-tide-server',
              version: '1.0.0',
            },
            {
              capabilities: {
                tools: {},
              },
            }
          );
          
          this.setupHandlers();
        }
        
        private setupHandlers() {
          // List available tools
          this.server.setRequestHandler(ListToolsRequestSchema, async () => {
            const tools = this.toolRegistry.getTools();
            return { tools };
          });
          
          // Execute tool calls
          this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
            const { name, arguments: args } = request.params;
            
            try {
              logger.info('Executing tool', { name, args });
              
              const result = await this.toolRegistry.executeTool(name, args);
              
              logger.info('Tool executed successfully', { name, result });
              return {
                content: [
                  {
                    type: 'text',
                    text: JSON.stringify(result, null, 2)
                  }
                ]
              };
              
            } catch (error) {
              logger.error('Tool execution failed', { name, error: error.message });
              
              // Return MCP-compliant error
              return {
                content: [
                  {
                    type: 'text',
                    text: JSON.stringify({
                      error: {
                        code: -32603, // Internal error
                        message: error.message,
                        data: { tool: name }
                      }
                    }, null, 2)
                  }
                ],
                isError: true
              };
            }
          });
        }
        
        async start() {
          // Initialize database connection
          await this.database.connect();
          
          // Initialize tools
          await this.toolRegistry.initialize();
          
          // Start MCP server
          const transport = new StdioServerTransport();
          await this.server.connect(transport);
          
          logger.info('EPIC-TIDE MCP server started successfully');
          
          // Handle graceful shutdown
          process.on('SIGINT', async () => {
            logger.info('Received SIGINT, shutting down gracefully');
            await this.database.disconnect();
            process.exit(0);
          });
        }
      }
      
      // Start server if run directly
      if (import.meta.url === `file://${process.argv[1]}`) {
        const server = new EpicTideMCPServer();
        server.start().catch((error) => {
          logger.error('Failed to start server', error);
          process.exit(1);
        });
      }
      
      export default EpicTideMCPServer;
    
    tool_registry: |
      // src/tools/registry.ts
      import { Tool } from '@modelcontextprotocol/sdk/types.js';
      import Ajv, { JSONSchemaType } from 'ajv';
      import { DatabaseService } from '../services/database.js';
      import { SaveWorkTool } from './save-work.js';
      import { CreatePathTool } from './create-path.js';
      import { StartTideTool } from './start-tide.js';
      import { UpdateExecutionTool } from './update-execution.js';
      import { CompleteTideTool } from './complete-tide.js';
      import { QueryPatternsTool } from './query-patterns.js';
      import { SynthesizeLearningsTool } from './synthesize-learnings.js';
      import { Logger } from '../utils/logger.js';
      
      const logger = Logger.getInstance();
      
      export interface EpicTideTool {
        definition: Tool;
        execute(args: any): Promise<any>;
      }
      
      export class ToolRegistry {
        private tools: Map<string, EpicTideTool> = new Map();
        private validator = new Ajv();
        
        constructor(private database: DatabaseService) {}
        
        async initialize() {
          // Register all EPIC-TIDE tools
          const toolInstances = [
            new SaveWorkTool(this.database),
            new CreatePathTool(this.database),
            new StartTideTool(this.database),
            new UpdateExecutionTool(this.database),
            new CompleteTideTool(this.database),
            new QueryPatternsTool(this.database),
            new SynthesizeLearningsTool(this.database)
          ];
          
          for (const tool of toolInstances) {
            this.tools.set(tool.definition.name, tool);
            logger.info('Registered tool', { name: tool.definition.name });
          }
        }
        
        getTools(): Tool[] {
          return Array.from(this.tools.values()).map(tool => tool.definition);
        }
        
        async executeTool(name: string, args: any): Promise<any> {
          const tool = this.tools.get(name);
          if (!tool) {
            throw new Error(`Tool not found: ${name}`);
          }
          
          // Validate input against schema
          const validate = this.validator.compile(tool.definition.inputSchema);
          const isValid = validate(args);
          
          if (!isValid) {
            const errors = validate.errors?.map(err => 
              `${err.instancePath}: ${err.message}`
            ).join(', ');
            throw new Error(`Input validation failed: ${errors}`);
          }
          
          // Execute tool
          return await tool.execute(args);
        }
      }
    
    save_work_tool: |
      // src/tools/save-work.ts
      import { Tool } from '@modelcontextprotocol/sdk/types.js';
      import { EpicTideTool } from './registry.js';
      import { DatabaseService } from '../services/database.js';
      import { Logger } from '../utils/logger.js';
      
      const logger = Logger.getInstance();
      
      export class SaveWorkTool implements EpicTideTool {
        definition: Tool = {
          name: 'epic_save_work',
          description: 'Save or update a WORK document with vector embeddings',
          inputSchema: {
            type: 'object',
            properties: {
              work_id: {
                type: 'string',
                description: 'Unique identifier for the work'
              },
              content: {
                type: 'object',
                description: 'Complete WORK document structure'
              },
              force_update: {
                type: 'boolean',
                default: false,
                description: 'Override existing work if it exists'
              }
            },
            required: ['work_id', 'content']
          }
        };
        
        constructor(private database: DatabaseService) {}
        
        async execute(args: {
          work_id: string;
          content: any;
          force_update?: boolean;
        }): Promise<{
          success: boolean;
          work_id: string;
          embedding_id?: string;
          version: number;
          error?: string;
        }> {
          try {
            logger.info('Saving WORK document', { work_id: args.work_id });
            
            // Check if work exists
            const existing = await this.database.getWork(args.work_id);
            if (existing && !args.force_update) {
              throw new Error(`Work already exists: ${args.work_id}. Use force_update=true to override.`);
            }
            
            // Generate embedding for the work content
            const contentText = JSON.stringify(args.content);
            const embedding = await this.database.generateEmbedding(contentText);
            
            // Save work with embedding
            const result = await this.database.saveWork({
              work_id: args.work_id,
              content: args.content,
              embedding: embedding,
              version: existing ? existing.version + 1 : 1
            });
            
            return {
              success: true,
              work_id: args.work_id,
              embedding_id: result.embedding_id,
              version: result.version
            };
            
          } catch (error) {
            logger.error('Failed to save work', { work_id: args.work_id, error: error.message });
            return {
              success: false,
              work_id: args.work_id,
              version: 0,
              error: error.message
            };
          }
        }
      }
    
    database_service: |
      // src/services/database.ts
      import { Pool, PoolClient } from 'pg';
      import { ConfigService } from './config.js';
      import { Logger } from '../utils/logger.js';
      
      const logger = Logger.getInstance();
      
      export interface WorkDocument {
        work_id: string;
        content: any;
        embedding: number[];
        version: number;
        created_at?: Date;
        updated_at?: Date;
      }
      
      export class DatabaseService {
        private pool: Pool;
        
        constructor(private config: ConfigService) {
          this.pool = new Pool({
            connectionString: this.config.getDatabaseUrl(),
            max: 20,
            idleTimeoutMillis: 30000,
            connectionTimeoutMillis: 2000,
          });
        }
        
        async connect(): Promise<void> {
          try {
            // Test connection
            const client = await this.pool.connect();
            await client.query('SELECT 1');
            client.release();
            
            logger.info('Database connected successfully');
          } catch (error) {
            logger.error('Database connection failed', error);
            throw error;
          }
        }
        
        async disconnect(): Promise<void> {
          await this.pool.end();
          logger.info('Database disconnected');
        }
        
        async saveWork(work: WorkDocument): Promise<{ embedding_id: string; version: number }> {
          const client = await this.pool.connect();
          
          try {
            await client.query('BEGIN');
            
            // Insert or update work
            const workResult = await client.query(`
              INSERT INTO epic_works (work_id, content, version, created_at, updated_at)
              VALUES ($1, $2, $3, NOW(), NOW())
              ON CONFLICT (work_id) 
              DO UPDATE SET 
                content = $2,
                version = $3,
                updated_at = NOW()
              RETURNING id, version
            `, [work.work_id, work.content, work.version]);
            
            // Save embedding
            const embeddingResult = await client.query(`
              INSERT INTO work_embeddings (work_id, embedding, created_at)
              VALUES ($1, $2::vector, NOW())
              ON CONFLICT (work_id)
              DO UPDATE SET 
                embedding = $2::vector,
                created_at = NOW()
              RETURNING id
            `, [work.work_id, JSON.stringify(work.embedding)]);
            
            await client.query('COMMIT');
            
            return {
              embedding_id: embeddingResult.rows[0].id,
              version: workResult.rows[0].version
            };
            
          } catch (error) {
            await client.query('ROLLBACK');
            throw error;
          } finally {
            client.release();
          }
        }
        
        async getWork(work_id: string): Promise<WorkDocument | null> {
          const result = await this.pool.query(`
            SELECT work_id, content, version, created_at, updated_at
            FROM epic_works
            WHERE work_id = $1
          `, [work_id]);
          
          return result.rows[0] || null;
        }
        
        async generateEmbedding(text: string): Promise<number[]> {
          // This would integrate with your embedding service
          // For now, return mock embedding of correct dimensions
          return new Array(1024).fill(0).map(() => Math.random() - 0.5);
        }
        
        async queryByEmbedding(
          embedding: number[], 
          limit: number = 10,
          minSimilarity: number = 0.7
        ): Promise<Array<{ work_id: string; content: any; similarity: number }>> {
          const result = await this.pool.query(`
            SELECT 
              w.work_id,
              w.content,
              1 - (e.embedding <=> $1::vector) AS similarity
            FROM epic_works w
            JOIN work_embeddings e ON w.work_id = e.work_id
            WHERE 1 - (e.embedding <=> $1::vector) > $2
            ORDER BY similarity DESC
            LIMIT $3
          `, [JSON.stringify(embedding), minSimilarity, limit]);
          
          return result.rows;
        }
      }
    
    config_service: |
      // src/services/config.ts
      import dotenv from 'dotenv';
      
      dotenv.config();
      
      export class ConfigService {
        getDatabaseUrl(): string {
          const url = process.env.DATABASE_URL;
          if (!url) {
            throw new Error('DATABASE_URL environment variable is required');
          }
          return url;
        }
        
        getEmbeddingModel(): string {
          return process.env.EMBEDDING_MODEL || 'intfloat/e5-large-v2';
        }
        
        getLogLevel(): string {
          return process.env.LOG_LEVEL || 'info';
        }
        
        getPort(): number {
          return parseInt(process.env.PORT || '3000', 10);
        }
      }
    
    logger_utility: |
      // src/utils/logger.ts
      import winston from 'winston';
      
      export class Logger {
        private static instance: winston.Logger;
        
        static getInstance(): winston.Logger {
          if (!Logger.instance) {
            Logger.instance = winston.createLogger({
              level: process.env.LOG_LEVEL || 'info',
              format: winston.format.combine(
                winston.format.timestamp(),
                winston.format.errors({ stack: true }),
                winston.format.json()
              ),
              defaultMeta: { service: 'epic-tide-mcp' },
              transports: [
                new winston.transports.Console({
                  format: winston.format.combine(
                    winston.format.colorize(),
                    winston.format.simple()
                  )
                })
              ]
            });
          }
          
          return Logger.instance;
        }
      }
    
    tsconfig: |
      {
        "compilerOptions": {
          "target": "ES2022",
          "module": "ES2022",
          "moduleResolution": "node",
          "allowSyntheticDefaultImports": true,
          "esModuleInterop": true,
          "allowImportingTsExtensions": false,
          "resolveJsonModule": true,
          "declaration": true,
          "outDir": "./dist",
          "rootDir": "./src",
          "strict": true,
          "noImplicitAny": true,
          "strictNullChecks": true,
          "strictFunctionTypes": true,
          "noImplicitReturns": true,
          "noFallthroughCasesInSwitch": true,
          "noUncheckedIndexedAccess": true,
          "skipLibCheck": true,
          "forceConsistentCasingInFileNames": true
        },
        "include": ["src/**/*"],
        "exclude": ["node_modules", "dist", "**/*.test.ts"]
      }
    
    commands: |
      # Setup MCP server project
      npm init -y
      npm install @modelcontextprotocol/sdk pg ajv winston dotenv uuid
      npm install -D @types/node @types/pg @types/uuid typescript tsx jest @types/jest
      
      # Build TypeScript
      npm run build
      
      # Start server in development
      npm run dev
      
      # Test MCP server (requires MCP client)
      npx @modelcontextprotocol/inspector src/server.ts
      
      # Run with Claude (add to Claude's MCP configuration)
      # ~/.config/claude/mcp.json:
      # {
      #   "servers": {
      #     "epic-tide": {
      #       "command": "node",
      #       "args": ["/path/to/dist/server.js"]
      #     }
      #   }
      # }
      
      # Test tool execution
      echo '{"jsonrpc":"2.0","method":"tools/call","params":{"name":"epic_save_work","arguments":{"work_id":"test","content":{"id":"test","what":"test work"}}},"id":1}' | node dist/server.js