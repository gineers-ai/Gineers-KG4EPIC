# WORK: Implement REST API (v4 AI-Native)
# Self-contained execution unit with embedded context

WORK:
  id: implement-rest-api
  what: "Build comprehensive POST-only REST API backend for EPIC-TIDE KG4EPIC"
  
  # CONTEXT - Environment and dependencies
  context:
    location: /Users/inseokseo/Gineers-Projects/Gineers-KG4EPIC
    prerequisites: 
      - "Node.js project setup with TypeScript"
      - "PostgreSQL+pgvector database running"
      - "API contracts designed (from design-api-contracts)"
      - "Database schema implemented"
    outputs:
      - "Express server with POST-only endpoints"
      - "WORK document CRUD operations"
      - "PATH creation and management"
      - "TIDE execution tracking"
      - "Semantic search capabilities"
      - "Vector embedding integration"
    dependencies: ["design-api-contracts", "design-database-schema", "setup-postgres-pgvector"]
    
  # KNOWLEDGE - Critical information
  knowledge:
    - "POST-only API design reduces attack surface and prevents accidental data exposure"
    - "All endpoints use POST with action parameters for security and consistency"
    - "Vector embeddings generated using E5-large-v2 (1024 dimensions)"
    - "PostgreSQL+pgvector enables semantic similarity search"
    - "API keys required for all operations except health checks"
    - "Request/response bodies must be JSON with proper validation"
    - "Database operations should use connection pooling for performance"
  
  # EXECUTION
  how:
    - "Setup Express server with TypeScript configuration"
    - "Implement POST-only routing architecture"
    - "Create WORK endpoints (save, query, update, delete)"
    - "Create PATH endpoints (create, list, execute)"
    - "Create TIDE endpoints (start, update, complete, status)"
    - "Add vector search endpoint for semantic queries"
    - "Integrate PostgreSQL with connection pooling"
    - "Add comprehensive error handling and logging"
    - "Implement request validation middleware"
  
  metrics:
    - "API server starts on port 3000"
    - "All endpoints return proper JSON responses"
    - "Database operations complete without errors"
    - "Vector search returns relevant results"
    - "API key authentication works correctly"
    - "Input validation rejects malformed requests"
  
  # LEARNINGS - From development experience
  learnings:
    - source: "API Design"
      learning: "POST-only APIs simplify security and client implementation"
    - source: "Database Integration"
      learning: "Connection pooling essential for handling concurrent requests"
    - source: "Vector Search"
      learning: "Combining embedding similarity with metadata filters improves relevance"
  
  # TROUBLESHOOTING - Known issues and fixes
  troubleshooting:
    - issue: "Database connection pool exhausted"
      symptoms: "API requests timeout or return connection errors"
      solution: "Increase pool size or reduce connection idle time"
      prevention: "Monitor connection usage and implement proper cleanup"
    
    - issue: "Vector search returns poor results"
      symptoms: "Semantic queries return irrelevant documents"
      solution: "Adjust similarity threshold and add metadata filtering"
      prevention: "Test embeddings with representative queries during development"
      
    - issue: "Large document uploads fail"
      symptoms: "413 Payload Too Large errors on WORK documents"
      solution: "Increase request body size limit to 10MB"
      prevention: "Test with realistic WORK document sizes"
    
    - issue: "Slow response times on search"
      symptoms: "Vector similarity queries take >5 seconds"
      solution: "Create pgvector index and optimize query structure"
      prevention: "Add database query performance monitoring"
  
  # COMPLETE IMPLEMENTATION
  artifacts:
    server_setup: |
      // src/server.ts
      import express from 'express';
      import cors from 'cors';
      import helmet from 'helmet';
      import { DatabaseService } from './services/database.js';
      import { EmbeddingService } from './services/embedding.js';
      import { WorkController } from './controllers/work.js';
      import { PathController } from './controllers/path.js';
      import { TideController } from './controllers/tide.js';
      import { SearchController } from './controllers/search.js';
      import { authenticateApiKey } from './middleware/auth.js';
      import { validateRequest } from './middleware/validation.js';
      import { errorHandler } from './middleware/error.js';
      import { Logger } from './utils/logger.js';
      
      const logger = Logger.getInstance();
      const app = express();
      const PORT = process.env.PORT || 3000;
      
      // Security middleware
      app.use(helmet());
      app.use(cors({
        origin: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],
        methods: ['POST', 'OPTIONS'],
        allowedHeaders: ['Content-Type', 'Authorization', 'X-API-Key']
      }));
      
      // Body parsing
      app.use(express.json({ limit: '10mb' }));
      app.use(express.urlencoded({ extended: true, limit: '10mb' }));
      
      // Health check (no auth required)
      app.get('/health', (req, res) => {
        res.json({ 
          status: 'healthy', 
          timestamp: new Date().toISOString(),
          version: '1.0.0'
        });
      });
      
      // Initialize services
      const database = new DatabaseService();
      const embedding = new EmbeddingService();
      const workController = new WorkController(database, embedding);
      const pathController = new PathController(database);
      const tideController = new TideController(database);
      const searchController = new SearchController(database, embedding);
      
      // Authentication for all API routes
      app.use('/api', authenticateApiKey);
      
      // Reject non-POST requests (except OPTIONS for CORS)
      app.use((req, res, next) => {
        if (req.method === 'GET' && req.path === '/health') {
          return next();
        }
        
        if (req.method !== 'POST' && req.method !== 'OPTIONS') {
          return res.status(405).json({
            error: 'Method not allowed. Only POST requests accepted.',
            code: 'METHOD_NOT_ALLOWED'
          });
        }
        
        next();
      });
      
      // API Routes
      
      // Work endpoints
      app.post('/api/works/save', validateRequest('saveWork'), workController.save.bind(workController));
      app.post('/api/works/get', validateRequest('getWork'), workController.get.bind(workController));
      app.post('/api/works/list', validateRequest('listWorks'), workController.list.bind(workController));
      app.post('/api/works/delete', validateRequest('deleteWork'), workController.delete.bind(workController));
      
      // Path endpoints
      app.post('/api/paths/create', validateRequest('createPath'), pathController.create.bind(pathController));
      app.post('/api/paths/get', validateRequest('getPath'), pathController.get.bind(pathController));
      app.post('/api/paths/list', validateRequest('listPaths'), pathController.list.bind(pathController));
      app.post('/api/paths/validate', validateRequest('validatePath'), pathController.validate.bind(pathController));
      
      // TIDE endpoints
      app.post('/api/tides/start', validateRequest('startTide'), tideController.start.bind(tideController));
      app.post('/api/tides/update', validateRequest('updateTide'), tideController.update.bind(tideController));
      app.post('/api/tides/complete', validateRequest('completeTide'), tideController.complete.bind(tideController));
      app.post('/api/tides/status', validateRequest('getTideStatus'), tideController.status.bind(tideController));
      
      // Search endpoints
      app.post('/api/search/semantic', validateRequest('semanticSearch'), searchController.semantic.bind(searchController));
      app.post('/api/search/patterns', validateRequest('patternSearch'), searchController.patterns.bind(searchController));
      
      // Error handling
      app.use(errorHandler);
      
      // Start server
      async function startServer() {
        try {
          await database.connect();
          await embedding.initialize();
          
          app.listen(PORT, () => {
            logger.info(`EPIC-TIDE API server running on port ${PORT}`);
          });
        } catch (error) {
          logger.error('Failed to start server', error);
          process.exit(1);
        }
      }
      
      startServer();
    
    work_controller: |
      // src/controllers/work.ts
      import { Request, Response } from 'express';
      import { DatabaseService } from '../services/database.js';
      import { EmbeddingService } from '../services/embedding.js';
      import { Logger } from '../utils/logger.js';
      
      const logger = Logger.getInstance();
      
      export class WorkController {
        constructor(
          private database: DatabaseService,
          private embedding: EmbeddingService
        ) {}
        
        async save(req: Request, res: Response) {
          try {
            const { work_id, content, force_update = false } = req.body;
            
            // Check if work exists
            const existing = await this.database.getWork(work_id);
            if (existing && !force_update) {
              return res.status(409).json({
                success: false,
                error: 'Work already exists. Use force_update=true to override.',
                code: 'WORK_EXISTS'
              });
            }
            
            // Generate embedding for content
            const contentText = this.extractTextFromWork(content);
            const embeddingVector = await this.embedding.generateEmbedding(contentText);
            
            // Save work
            const result = await this.database.saveWork({
              work_id,
              content,
              embedding: embeddingVector,
              version: existing ? existing.version + 1 : 1
            });
            
            logger.info('Work saved successfully', { work_id, version: result.version });
            
            res.json({
              success: true,
              work_id,
              version: result.version,
              embedding_id: result.embedding_id
            });
            
          } catch (error) {
            logger.error('Failed to save work', { error: error.message });
            res.status(500).json({
              success: false,
              error: error.message,
              code: 'SAVE_FAILED'
            });
          }
        }
        
        async get(req: Request, res: Response) {
          try {
            const { work_id } = req.body;
            
            const work = await this.database.getWork(work_id);
            if (!work) {
              return res.status(404).json({
                success: false,
                error: 'Work not found',
                code: 'WORK_NOT_FOUND'
              });
            }
            
            res.json({
              success: true,
              work
            });
            
          } catch (error) {
            logger.error('Failed to get work', { error: error.message });
            res.status(500).json({
              success: false,
              error: error.message,
              code: 'GET_FAILED'
            });
          }
        }
        
        async list(req: Request, res: Response) {
          try {
            const { 
              limit = 50, 
              offset = 0, 
              filter = {} 
            } = req.body;
            
            const works = await this.database.listWorks({
              limit,
              offset,
              filter
            });
            
            res.json({
              success: true,
              works: works.items,
              total: works.total,
              limit,
              offset
            });
            
          } catch (error) {
            logger.error('Failed to list works', { error: error.message });
            res.status(500).json({
              success: false,
              error: error.message,
              code: 'LIST_FAILED'
            });
          }
        }
        
        async delete(req: Request, res: Response) {
          try {
            const { work_id } = req.body;
            
            const deleted = await this.database.deleteWork(work_id);
            if (!deleted) {
              return res.status(404).json({
                success: false,
                error: 'Work not found',
                code: 'WORK_NOT_FOUND'
              });
            }
            
            logger.info('Work deleted successfully', { work_id });
            
            res.json({
              success: true,
              work_id,
              deleted: true
            });
            
          } catch (error) {
            logger.error('Failed to delete work', { error: error.message });
            res.status(500).json({
              success: false,
              error: error.message,
              code: 'DELETE_FAILED'
            });
          }
        }
        
        private extractTextFromWork(content: any): string {
          // Extract searchable text from WORK document
          const parts = [];
          
          if (content.what) parts.push(content.what);
          if (content.how && Array.isArray(content.how)) {
            parts.push(...content.how);
          }
          if (content.knowledge && Array.isArray(content.knowledge)) {
            parts.push(...content.knowledge);
          }
          if (content.learnings && Array.isArray(content.learnings)) {
            content.learnings.forEach(learning => {
              if (learning.learning) parts.push(learning.learning);
            });
          }
          
          return parts.join(' ');
        }
      }
    
    search_controller: |
      // src/controllers/search.ts
      import { Request, Response } from 'express';
      import { DatabaseService } from '../services/database.js';
      import { EmbeddingService } from '../services/embedding.js';
      import { Logger } from '../utils/logger.js';
      
      const logger = Logger.getInstance();
      
      export class SearchController {
        constructor(
          private database: DatabaseService,
          private embedding: EmbeddingService
        ) {}
        
        async semantic(req: Request, res: Response) {
          try {
            const { 
              query, 
              limit = 10, 
              min_similarity = 0.7,
              filters = {}
            } = req.body;
            
            // Generate embedding for query
            const queryEmbedding = await this.embedding.generateEmbedding(query);
            
            // Perform vector similarity search
            const results = await this.database.searchByEmbedding({
              embedding: queryEmbedding,
              limit,
              minSimilarity: min_similarity,
              filters
            });
            
            res.json({
              success: true,
              query,
              results: results.map(result => ({
                work_id: result.work_id,
                content: result.content,
                similarity: result.similarity,
                matched_content: this.highlightMatches(result.content, query)
              })),
              total: results.length
            });
            
          } catch (error) {
            logger.error('Semantic search failed', { error: error.message });
            res.status(500).json({
              success: false,
              error: error.message,
              code: 'SEARCH_FAILED'
            });
          }
        }
        
        async patterns(req: Request, res: Response) {
          try {
            const { 
              pattern_type,
              time_range,
              min_frequency = 2,
              limit = 20
            } = req.body;
            
            const patterns = await this.database.extractPatterns({
              type: pattern_type,
              timeRange: time_range,
              minFrequency: min_frequency,
              limit
            });
            
            res.json({
              success: true,
              patterns: patterns.map(pattern => ({
                pattern: pattern.pattern,
                frequency: pattern.frequency,
                confidence: pattern.confidence,
                examples: pattern.examples,
                first_seen: pattern.first_seen,
                last_seen: pattern.last_seen
              })),
              total: patterns.length
            });
            
          } catch (error) {
            logger.error('Pattern search failed', { error: error.message });
            res.status(500).json({
              success: false,
              error: error.message,
              code: 'PATTERN_SEARCH_FAILED'
            });
          }
        }
        
        private highlightMatches(content: any, query: string): string {
          // Simple text matching for highlighting
          const text = JSON.stringify(content, null, 2);
          const queryTerms = query.toLowerCase().split(' ');
          
          let highlighted = text;
          queryTerms.forEach(term => {
            const regex = new RegExp(`(${term})`, 'gi');
            highlighted = highlighted.replace(regex, '**$1**');
          });
          
          return highlighted.substring(0, 500) + '...';
        }
      }
    
    validation_middleware: |
      // src/middleware/validation.ts
      import { Request, Response, NextFunction } from 'express';
      import Ajv, { JSONSchemaType } from 'ajv';
      
      const ajv = new Ajv();
      
      const schemas = {
        saveWork: {
          type: 'object',
          properties: {
            work_id: { type: 'string', minLength: 1, maxLength: 100 },
            content: { type: 'object' },
            force_update: { type: 'boolean' }
          },
          required: ['work_id', 'content'],
          additionalProperties: false
        },
        
        getWork: {
          type: 'object',
          properties: {
            work_id: { type: 'string', minLength: 1, maxLength: 100 }
          },
          required: ['work_id'],
          additionalProperties: false
        },
        
        semanticSearch: {
          type: 'object',
          properties: {
            query: { type: 'string', minLength: 1, maxLength: 1000 },
            limit: { type: 'integer', minimum: 1, maximum: 100 },
            min_similarity: { type: 'number', minimum: 0, maximum: 1 },
            filters: { type: 'object' }
          },
          required: ['query'],
          additionalProperties: false
        }
        
        // Add more schemas as needed...
      };
      
      export function validateRequest(schemaName: keyof typeof schemas) {
        return (req: Request, res: Response, next: NextFunction) => {
          const schema = schemas[schemaName];
          const validate = ajv.compile(schema);
          
          if (!validate(req.body)) {
            return res.status(400).json({
              success: false,
              error: 'Validation failed',
              code: 'VALIDATION_ERROR',
              details: validate.errors?.map(err => ({
                field: err.instancePath || err.schemaPath,
                message: err.message,
                value: err.data
              }))
            });
          }
          
          next();
        };
      }
    
    embedding_service: |
      // src/services/embedding.ts
      import { Logger } from '../utils/logger.js';
      
      const logger = Logger.getInstance();
      
      export class EmbeddingService {
        private model: string;
        
        constructor() {
          this.model = process.env.EMBEDDING_MODEL || 'intfloat/e5-large-v2';
        }
        
        async initialize(): Promise<void> {
          // Initialize embedding service connection
          logger.info('Embedding service initialized', { model: this.model });
        }
        
        async generateEmbedding(text: string): Promise<number[]> {
          try {
            // This would integrate with your actual embedding service
            // For now, return mock embedding with correct dimensions
            logger.debug('Generating embedding', { textLength: text.length });
            
            // Mock E5-large-v2 embedding (1024 dimensions)
            const embedding = new Array(1024).fill(0).map(() => Math.random() - 0.5);
            
            return embedding;
            
          } catch (error) {
            logger.error('Embedding generation failed', { error: error.message });
            throw new Error(`Failed to generate embedding: ${error.message}`);
          }
        }
        
        async generateBatchEmbeddings(texts: string[]): Promise<number[][]> {
          try {
            const embeddings = await Promise.all(
              texts.map(text => this.generateEmbedding(text))
            );
            
            return embeddings;
            
          } catch (error) {
            logger.error('Batch embedding generation failed', { error: error.message });
            throw new Error(`Failed to generate batch embeddings: ${error.message}`);
          }
        }
      }
    
    package_json_api: |
      {
        "name": "epic-tide-api",
        "version": "1.0.0",
        "description": "POST-only REST API for EPIC-TIDE KG4EPIC",
        "main": "dist/server.js",
        "type": "module",
        "scripts": {
          "build": "tsc",
          "start": "node dist/server.js",
          "dev": "tsx src/server.ts",
          "test": "jest",
          "test:watch": "jest --watch",
          "lint": "eslint src --ext .ts",
          "format": "prettier --write src/**/*.ts"
        },
        "dependencies": {
          "express": "^4.18.2",
          "cors": "^2.8.5",
          "helmet": "^7.1.0",
          "pg": "^8.11.3",
          "winston": "^3.11.0",
          "express-validator": "^7.0.1",
          "express-rate-limit": "^7.1.5",
          "dotenv": "^16.3.1",
          "uuid": "^9.0.1",
          "ajv": "^8.12.0"
        },
        "devDependencies": {
          "@types/node": "^20.0.0",
          "@types/express": "^4.17.21",
          "@types/cors": "^2.8.17",
          "@types/pg": "^8.10.7",
          "@types/uuid": "^9.0.6",
          "typescript": "^5.2.0",
          "tsx": "^4.0.0",
          "jest": "^29.7.0",
          "@types/jest": "^29.5.6",
          "supertest": "^6.3.3",
          "@types/supertest": "^2.0.16",
          "eslint": "^8.52.0",
          "prettier": "^3.0.0"
        }
      }
    
    commands: |
      # Setup API project
      npm install express cors helmet pg winston express-validator express-rate-limit
      npm install -D @types/express @types/cors @types/pg typescript tsx jest supertest
      
      # Build TypeScript
      npm run build
      
      # Start development server
      npm run dev
      
      # Test API endpoints
      
      # Save a work document
      curl -X POST http://localhost:3000/api/works/save \
        -H "X-API-Key: your-api-key" \
        -H "Content-Type: application/json" \
        -d '{
          "work_id": "test-work",
          "content": {
            "id": "test-work",
            "what": "Test WORK document for API testing",
            "how": ["Create test data", "Validate API response"],
            "metrics": ["API responds with 200", "Data saved to database"]
          }
        }'
      
      # Get a work document
      curl -X POST http://localhost:3000/api/works/get \
        -H "X-API-Key: your-api-key" \
        -H "Content-Type: application/json" \
        -d '{"work_id": "test-work"}'
      
      # Semantic search
      curl -X POST http://localhost:3000/api/search/semantic \
        -H "X-API-Key: your-api-key" \
        -H "Content-Type: application/json" \
        -d '{
          "query": "API testing and validation",
          "limit": 5,
          "min_similarity": 0.7
        }'
      
      # List all works
      curl -X POST http://localhost:3000/api/works/list \
        -H "X-API-Key: your-api-key" \
        -H "Content-Type: application/json" \
        -d '{"limit": 10, "offset": 0}'
      
      # Test rate limiting (run multiple times quickly)
      for i in {1..5}; do
        curl -X POST http://localhost:3000/api/works/list \
          -H "X-API-Key: your-api-key" \
          -H "Content-Type: application/json" \
          -d '{"limit": 10}'
      done