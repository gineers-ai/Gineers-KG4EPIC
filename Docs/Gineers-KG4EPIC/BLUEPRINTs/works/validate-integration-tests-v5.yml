# WORK: Create and Validate Integration Tests
# Ensures all KG4EPIC functionality is tested and validated

WORK:
  id: validate-integration-tests-v5
  what: "Create comprehensive integration tests for KG4EPIC API"
  why: "TIDE_1 has no tests - need evidence that functionality works"
  how: "Build test suite covering all endpoints, run in Docker environment"
  version: 1.0
  
  # CONTEXT - Everything needed to understand this WORK
  context:
    background: |
      TIDE_1 implemented:
      - work.ts routes (save, get, search)
      - path.ts routes (save, get, search)
      - tide.ts routes (start, update, complete)
      - No tests created
      - No validation performed
      
    test_requirements: |
      - Test all API endpoints
      - Validate database operations
      - Check embedding generation
      - Verify semantic search
      - Test error cases
      - Run in Docker environment
      
    dependencies:
      - Jest testing framework
      - Supertest for API testing
      - Docker test environment
      - Test database setup
      
  # KNOWLEDGE - Critical information for execution
  knowledge:
    testing_strategy: |
      1. Unit tests: Individual functions
      2. Integration tests: API endpoints with database
      3. E2E tests: Complete workflows
      4. Performance tests: Response times
      5. Docker tests: Container environment
      
    test_patterns: |
      - Arrange: Set up test data
      - Act: Execute operation
      - Assert: Verify results
      - Cleanup: Reset state
      
    coverage_targets: |
      - Line coverage: > 80%
      - Branch coverage: > 75%
      - Function coverage: > 90%
      - Integration coverage: 100% of endpoints
      
  # ARTIFACTS - Implementation details
  artifacts:
    test_structure: |
      tests/
      ├── unit/
      │   ├── services/
      │   │   ├── embedding.test.ts
      │   │   └── database.test.ts
      │   └── utils/
      │       └── validation.test.ts
      ├── integration/
      │   ├── work.test.ts
      │   ├── path.test.ts
      │   ├── tide.test.ts
      │   └── search.test.ts
      ├── e2e/
      │   └── epic-tide-flow.test.ts
      └── fixtures/
          ├── test-data.ts
          └── test-utils.ts
          
    work_tests: |
      // tests/integration/work.test.ts
      import request from 'supertest';
      import { app } from '../../src/app';
      import { pool } from '../../src/config/database';
      
      describe('WORK API Endpoints', () => {
        beforeAll(async () => {
          // Clean test data
          await pool.query('DELETE FROM works WHERE work_id LIKE $1', ['test_%']);
        });
        
        afterAll(async () => {
          await pool.end();
        });
        
        describe('POST /api/work.save', () => {
          it('should save a new work', async () => {
            const work = {
              work_id: 'test_work_1',
              what: 'Test work creation',
              why: 'Validate save endpoint',
              how: 'Send POST request',
              context: { test: true },
              knowledge: { key: 'value' }
            };
            
            const response = await request(app)
              .post('/api/work.save')
              .send(work)
              .expect(200);
              
            expect(response.body.success).toBe(true);
            expect(response.body.work.work_id).toBe('test_work_1');
            expect(response.body.work.what_embedding).toBeDefined();
          });
          
          it('should update existing work', async () => {
            const update = {
              work_id: 'test_work_1',
              what: 'Updated test work',
              version: '1.1'
            };
            
            const response = await request(app)
              .post('/api/work.save')
              .send(update)
              .expect(200);
              
            expect(response.body.work.what).toBe('Updated test work');
            expect(response.body.work.version).toBe('1.1');
          });
          
          it('should handle missing required fields', async () => {
            const invalid = { what: 'Missing work_id' };
            
            const response = await request(app)
              .post('/api/work.save')
              .send(invalid)
              .expect(400);
              
            expect(response.body.success).toBe(false);
            expect(response.body.error).toContain('work_id');
          });
        });
        
        describe('POST /api/work.get', () => {
          it('should retrieve work by id', async () => {
            const response = await request(app)
              .post('/api/work.get')
              .send({ work_id: 'test_work_1' })
              .expect(200);
              
            expect(response.body.success).toBe(true);
            expect(response.body.work.work_id).toBe('test_work_1');
          });
          
          it('should return null for non-existent work', async () => {
            const response = await request(app)
              .post('/api/work.get')
              .send({ work_id: 'non_existent' })
              .expect(404);
              
            expect(response.body.success).toBe(false);
          });
        });
        
        describe('POST /api/work.search', () => {
          beforeAll(async () => {
            // Create test works
            const works = [
              { work_id: 'test_nodejs', what: 'Setup Node.js project' },
              { work_id: 'test_docker', what: 'Configure Docker environment' },
              { work_id: 'test_database', what: 'Design database schema' }
            ];
            
            for (const work of works) {
              await request(app).post('/api/work.save').send(work);
            }
          });
          
          it('should search works semantically', async () => {
            const response = await request(app)
              .post('/api/work.search')
              .send({ query: 'initialize nodejs application' })
              .expect(200);
              
            expect(response.body.success).toBe(true);
            expect(response.body.results.length).toBeGreaterThan(0);
            expect(response.body.results[0].similarity).toBeGreaterThan(0.5);
          });
        });
      });
      
    tide_flow_test: |
      // tests/e2e/epic-tide-flow.test.ts
      import request from 'supertest';
      import { app } from '../../src/app';
      
      describe('EPIC-TIDE Complete Flow', () => {
        let phaseId: string;
        let pathId: string;
        let tideId: string;
        
        it('should execute complete EPIC-TIDE flow', async () => {
          // 1. Create PHASE
          const phaseResponse = await request(app)
            .post('/api/phase.save')
            .send({
              phase_id: 'test_phase',
              what: 'Test phase for E2E',
              strategy: { test: true }
            })
            .expect(200);
          
          phaseId = phaseResponse.body.phase.id;
          
          // 2. Create PATH under PHASE
          const pathResponse = await request(app)
            .post('/api/path.save')
            .send({
              path_id: 'test_path',
              phase_id: phaseId,
              what: 'Test path execution',
              project: { name: 'test' }
            })
            .expect(200);
            
          pathId = pathResponse.body.path.id;
          
          // 3. Create WORKs
          const work1 = await request(app)
            .post('/api/work.save')
            .send({
              work_id: 'test_work_flow_1',
              what: 'First test work'
            })
            .expect(200);
            
          // 4. Link WORK to PATH
          await request(app)
            .post('/api/path.addWork')
            .send({
              path_id: pathId,
              work_id: work1.body.work.id,
              sequence: 1
            })
            .expect(200);
            
          // 5. Start TIDE
          const tideResponse = await request(app)
            .post('/api/tide.start')
            .send({
              path_id: pathId,
              context: { test_run: true }
            })
            .expect(200);
            
          tideId = tideResponse.body.tide.id;
          expect(tideResponse.body.tide.tide_number).toBe(1);
          
          // 6. Update TIDE progress
          await request(app)
            .post('/api/tide.update')
            .send({
              tide_id: tideId,
              execution: {
                'test_work_flow_1': {
                  status: 'complete',
                  evidence: 'Work completed successfully'
                }
              }
            })
            .expect(200);
            
          // 7. Complete TIDE
          const completeResponse = await request(app)
            .post('/api/tide.complete')
            .send({
              tide_id: tideId,
              outcome: 'success',
              learnings: {
                technical: ['E2E test successful'],
                process: ['Flow validated']
              }
            })
            .expect(200);
            
          expect(completeResponse.body.tide.outcome).toBe('success');
          expect(completeResponse.body.tide.completed_at).toBeDefined();
        });
      });
      
    test_docker_compose: |
      # docker-compose.test.yml
      version: '3.8'
      
      services:
        test:
          build:
            context: .
            dockerfile: Dockerfile.test
          container_name: kg4epic-test
          environment:
            NODE_ENV: test
            DATABASE_URL: postgresql://kg4epic_user:kg4epic_pass@postgres:5432/kg4epic_test
          volumes:
            - ./tests:/app/tests
            - ./coverage:/app/coverage
          command: ["npm", "run", "test:integration"]
          depends_on:
            postgres:
              condition: service_healthy
          networks:
            - kg4epic-network
            
    jest_config: |
      // jest.config.js
      module.exports = {
        preset: 'ts-jest',
        testEnvironment: 'node',
        roots: ['<rootDir>/tests'],
        collectCoverageFrom: [
          'src/**/*.ts',
          '!src/**/*.d.ts',
          '!src/**/index.ts'
        ],
        coverageThreshold: {
          global: {
            lines: 80,
            branches: 75,
            functions: 90,
            statements: 80
          }
        },
        setupFilesAfterEnv: ['<rootDir>/tests/setup.ts'],
        testTimeout: 30000
      };
      
    test_scripts: |
      // package.json scripts
      "scripts": {
        "test": "jest",
        "test:unit": "jest tests/unit",
        "test:integration": "jest tests/integration",
        "test:e2e": "jest tests/e2e",
        "test:docker": "docker-compose -f docker-compose.test.yml up --abort-on-container-exit",
        "test:coverage": "jest --coverage",
        "test:watch": "jest --watch"
      }
      
  # TROUBLESHOOTING - Known issues and solutions
  troubleshooting:
    database_connection: |
      Problem: Tests cannot connect to database
      Solution: Ensure test database exists and migrations ran
      
    embedding_timeout: |
      Problem: Embedding tests timeout
      Solution: Mock embedding service or increase timeout
      
    flaky_tests: |
      Problem: Tests pass/fail randomly
      Solution: Add proper cleanup, avoid shared state
      
    docker_tests_fail: |
      Problem: Tests fail in Docker but pass locally
      Solution: Check environment variables and network config
      
  # SUCCESS CRITERIA
  success_criteria:
    - All endpoints have integration tests
    - E2E flow tests pass
    - Coverage targets met (80%+ lines)
    - Tests run in Docker environment
    - CI/CD pipeline ready
    - No flaky tests
    
  # EXECUTION NOTES
  execution_notes: |
    1. Install test dependencies (jest, supertest)
    2. Create test structure
    3. Write integration tests for each endpoint
    4. Create E2E flow test
    5. Set up Docker test environment
    6. Run tests and check coverage
    7. Fix any failing tests
    8. Document test commands
    
  # PHASE ALIGNMENT
  phase_context:
    phase_id: phase_1_free
    contribution: "Provides evidence that KG4EPIC functionality works"
    enables: "Confidence in system reliability and correctness"