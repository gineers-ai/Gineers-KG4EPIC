# WORK: Validate and Complete Semantic Search
# Ensures semantic search actually works with E5-large-v2

WORK:
  id: validate-semantic-search-v5
  what: "Complete and validate semantic search with E5-large-v2 embeddings"
  why: "TIDE_1 implemented basic API but semantic search not validated"
  how: "Add search endpoints, test vector operations, validate results"
  version: 1.0
  
  # CONTEXT - Everything needed to understand this WORK
  context:
    background: |
      TIDE_1 status:
      - E5-large-v2 embedding service exists in services/embedding.ts
      - Database has vector columns (1024 dimensions)
      - Basic work/path/tide routes implemented
      - Search endpoints not yet implemented
      
    current_state: |
      - API container running as kg4epic-api
      - PostgreSQL with pgvector extension
      - E5-large-v2 model available (~2GB cached)
      - Vector columns in works and patterns tables
      
    dependencies:
      - v5.1 database schema deployed
      - E5-large-v2 embedding service
      - API server running in Docker
      
  # KNOWLEDGE - Critical information for execution
  knowledge:
    e5_requirements: |
      - Model: intfloat/e5-large-v2
      - Dimensions: 1024
      - Requires "query:" prefix for search queries
      - Requires "passage:" prefix for indexed content
      - Loads on first use (~30 seconds)
      
    pgvector_operations: |
      - Distance functions: <-> (L2), <=> (cosine), <#> (inner product)
      - Recommend cosine similarity for E5 embeddings
      - Index type: ivfflat for performance
      - Lists parameter: ~100 for small datasets
      
    search_strategy: |
      1. Generate query embedding with "query:" prefix
      2. Search using cosine similarity
      3. Apply threshold (e.g., > 0.7 similarity)
      4. Combine with keyword filters
      5. Return ranked results
      
  # ARTIFACTS - Implementation details
  artifacts:
    search_endpoints: |
      // src/api/routes/search.ts
      import { Router } from 'express';
      import { Pool } from 'pg';
      import { generateEmbedding } from '../../services/embedding';
      
      const router = Router();
      const pool = new Pool({ connectionString: process.env.DATABASE_URL });
      
      // POST /api/search.semantic
      router.post('/search.semantic', async (req, res) => {
        try {
          const { query, entity_type = 'work', limit = 10, threshold = 0.7 } = req.body;
          
          if (!query) {
            return res.status(400).json({ 
              success: false, 
              error: 'Query required' 
            });
          }
          
          // Generate query embedding with prefix
          const queryEmbedding = await generateEmbedding(`query: ${query}`);
          
          // Determine table and column based on entity type
          const searchConfigs = {
            work: { table: 'works', column: 'what_embedding', fields: 'work_id, what, why' },
            path: { table: 'paths', column: 'project_embedding', fields: 'path_id, what' },
            pattern: { table: 'patterns', column: 'pattern_embedding', fields: 'pattern_name, pattern_type' }
          };
          
          const config = searchConfigs[entity_type];
          if (!config) {
            return res.status(400).json({ 
              success: false, 
              error: 'Invalid entity_type' 
            });
          }
          
          // Perform cosine similarity search
          const searchQuery = `
            SELECT 
              ${config.fields},
              1 - (${config.column} <=> $1::vector) as similarity
            FROM ${config.table}
            WHERE ${config.column} IS NOT NULL
              AND 1 - (${config.column} <=> $1::vector) > $2
            ORDER BY similarity DESC
            LIMIT $3
          `;
          
          const result = await pool.query(searchQuery, [
            `[${queryEmbedding.join(',')}]`,
            threshold,
            limit
          ]);
          
          res.json({
            success: true,
            query,
            entity_type,
            results: result.rows,
            count: result.rows.length
          });
          
        } catch (error) {
          console.error('Semantic search error:', error);
          res.status(500).json({ 
            success: false, 
            error: error.message 
          });
        }
      });
      
      // POST /api/search.hybrid
      router.post('/search.hybrid', async (req, res) => {
        try {
          const { query, filters = {}, limit = 10 } = req.body;
          
          if (!query) {
            return res.status(400).json({ 
              success: false, 
              error: 'Query required' 
            });
          }
          
          // Generate embedding
          const queryEmbedding = await generateEmbedding(`query: ${query}`);
          
          // Build filter conditions
          let filterConditions = '';
          const filterValues = [];
          let paramCount = 3;
          
          if (filters.version) {
            filterConditions += ` AND version = $${++paramCount}`;
            filterValues.push(filters.version);
          }
          
          if (filters.status) {
            filterConditions += ` AND status = $${++paramCount}`;
            filterValues.push(filters.status);
          }
          
          // Hybrid search: semantic + keyword
          const hybridQuery = `
            WITH semantic_results AS (
              SELECT 
                work_id, what, why,
                1 - (what_embedding <=> $1::vector) as semantic_score
              FROM works
              WHERE what_embedding IS NOT NULL
            ),
            keyword_results AS (
              SELECT 
                work_id,
                ts_rank(to_tsvector('english', what || ' ' || COALESCE(why, '')), 
                       plainto_tsquery('english', $2)) as keyword_score
              FROM works
            )
            SELECT 
              w.work_id, w.what, w.why,
              COALESCE(sr.semantic_score, 0) * 0.7 + 
              COALESCE(kr.keyword_score, 0) * 0.3 as combined_score
            FROM works w
            LEFT JOIN semantic_results sr ON w.work_id = sr.work_id
            LEFT JOIN keyword_results kr ON w.work_id = kr.work_id
            WHERE (sr.semantic_score > 0.5 OR kr.keyword_score > 0)
              ${filterConditions}
            ORDER BY combined_score DESC
            LIMIT $3
          `;
          
          const result = await pool.query(hybridQuery, [
            `[${queryEmbedding.join(',')}]`,
            query,
            limit,
            ...filterValues
          ]);
          
          res.json({
            success: true,
            query,
            search_type: 'hybrid',
            results: result.rows,
            count: result.rows.length
          });
          
        } catch (error) {
          console.error('Hybrid search error:', error);
          res.status(500).json({ 
            success: false, 
            error: error.message 
          });
        }
      });
      
      export default router;
      
    embedding_storage: |
      // Add to existing save endpoints to generate embeddings
      
      // In work.save endpoint
      if (work.what) {
        work.what_embedding = await generateEmbedding(`passage: ${work.what}`);
      }
      if (work.why) {
        work.why_embedding = await generateEmbedding(`passage: ${work.why}`);
      }
      if (work.knowledge) {
        const knowledgeText = JSON.stringify(work.knowledge);
        work.knowledge_embedding = await generateEmbedding(`passage: ${knowledgeText}`);
      }
      
    test_queries: |
      -- Test semantic search
      -- 1. Insert test data with embeddings
      INSERT INTO works (work_id, what, what_embedding) 
      VALUES ('test_work_1', 'Setup Node.js project with TypeScript', 
              (SELECT array_agg(random())::vector(1024) FROM generate_series(1,1024)));
      
      -- 2. Test cosine similarity search
      SELECT work_id, what, 
             1 - (what_embedding <=> (SELECT array_agg(random())::vector(1024) FROM generate_series(1,1024))) as similarity
      FROM works
      WHERE what_embedding IS NOT NULL
      ORDER BY similarity DESC;
      
      -- 3. Check index usage
      EXPLAIN (ANALYZE, BUFFERS) 
      SELECT work_id FROM works 
      ORDER BY what_embedding <=> (SELECT array_agg(0.5)::vector(1024) FROM generate_series(1,1024))
      LIMIT 10;
      
    integration_test: |
      // test/semantic-search.test.ts
      import axios from 'axios';
      
      describe('Semantic Search', () => {
        const API_URL = 'http://localhost:3000/api';
        
        beforeAll(async () => {
          // Create test work with embedding
          await axios.post(`${API_URL}/work.save`, {
            work_id: 'test_nodejs_setup',
            what: 'Setup Node.js project with TypeScript and Express',
            why: 'Need a robust backend API server'
          });
        });
        
        it('should find relevant works by semantic search', async () => {
          const response = await axios.post(`${API_URL}/search.semantic`, {
            query: 'initialize nodejs application',
            entity_type: 'work',
            limit: 5
          });
          
          expect(response.data.success).toBe(true);
          expect(response.data.results.length).toBeGreaterThan(0);
          expect(response.data.results[0].similarity).toBeGreaterThan(0.7);
        });
        
        it('should perform hybrid search', async () => {
          const response = await axios.post(`${API_URL}/search.hybrid`, {
            query: 'typescript setup',
            limit: 5
          });
          
          expect(response.data.success).toBe(true);
          expect(response.data.results.length).toBeGreaterThan(0);
        });
        
        it('should handle search with no results', async () => {
          const response = await axios.post(`${API_URL}/search.semantic`, {
            query: 'completely unrelated quantum physics topic',
            entity_type: 'work',
            threshold: 0.9
          });
          
          expect(response.data.success).toBe(true);
          expect(response.data.results.length).toBe(0);
        });
      });
      
  # TROUBLESHOOTING - Known issues and solutions
  troubleshooting:
    embedding_timeout: |
      Problem: E5 model takes too long to load
      Solution: Pre-warm the model on server start
      
    vector_dimension_mismatch: |
      Problem: dimension of vector (1024) does not match dimension of column
      Solution: Ensure all vectors are exactly 1024 dimensions
      
    low_similarity_scores: |
      Problem: All similarity scores are low
      Solution: Check query/passage prefixes are used correctly
      
    slow_search: |
      Problem: Vector search is slow
      Solution: Create ivfflat index, adjust lists parameter
      
  # SUCCESS CRITERIA
  success_criteria:
    - Search endpoints return relevant results
    - Similarity scores > 0.7 for related queries
    - Hybrid search combines semantic and keyword
    - Embeddings generated and stored for all entities
    - Search completes in < 500ms for 1000 documents
    - Integration tests pass
    
  # EXECUTION NOTES
  execution_notes: |
    1. Add search routes to API
    2. Update save endpoints to generate embeddings
    3. Test with sample queries
    4. Validate similarity scores
    5. Run integration tests
    6. Document search API
    
  # PHASE ALIGNMENT
  phase_context:
    phase_id: phase_1_free
    contribution: "Enables semantic discovery of EPIC-TIDE knowledge"
    enables: "Find relevant WORKs, PATHs, and PATTERNs by meaning"